class App {
  var _vector3 = THREE.Vector3.new()
  var _scene = THREE.Scene.new()
  var _camera = THREE.PerspectiveCamera.new(75, 1, 0.1, 1000)
  var _renderer = THREE.WebGLRenderer.new()
  var _world World = null
  var _cameraAABB = AABB.new

  def new {
    _world = World.new(_scene)
    _cameraAABB.center.y = 50
    _cameraAABB.radius.set(0.4, 0.4, 0.4)
    _camera.rotation.order = "YXZ"
    _renderer.setClearColor(_world.clearColor)
    _renderer.gammaInput = true
    _renderer.gammaOutput = true
  }

  def element dynamic {
    return _renderer.domElement
  }

  def resize(width int, height int) {
    _camera.setViewOffset(width, height, 0, 0, width, height)
    _camera.updateProjectionMatrix()
    _renderer.setSize(width, height)
  }

  def moveCamera(deltaX double, deltaY double) {
    if deltaX != 0 || deltaY != 0 {
      _vector3.set(deltaX, 0, deltaY)
      _vector3.applyEuler(_camera.rotation)
      _world.moveAABB(_cameraAABB, _vector3)
    }
  }

  def rotateCamera(deltaX double, deltaY double) {
    var rotation = _camera.rotation
    rotation.x = Math.min(Math.PI / 2, Math.max(-Math.PI / 2, rotation.x - deltaY))
    rotation.y -= deltaX
    rotation.y -= Math.floor(rotation.y / (Math.PI * 2)) * (Math.PI * 2)
  }

  def tick(seconds double) {
    _camera.position.copy(_cameraAABB.center)
    _camera.updateMatrixWorld()
    _camera.matrixWorldInverse.getInverse(_camera.matrixWorld)
    _world.tick(_camera)
    _renderer.render(_scene, _camera)
  }
}
