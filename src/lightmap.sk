class Lightmap {
  const width int
  const height int
  const depthScene = THREE.Scene.new()
  const updateScene = THREE.Scene.new()
  const _clearScene = THREE.Scene.new()
  const depthMaterial dynamic
  const updateMaterial dynamic
  const _clearMaterial dynamic
  const _depthTexture dynamic
  const _links Int32Array
  const _box2 = THREE.Box2.new()
  const _box3 = THREE.Box3.new()
  const _vector3 = THREE.Vector3.new()
  const _axisX = THREE.Vector3.new()
  const _axisY = THREE.Vector3.new()
  const _axisZ = THREE.Vector3.new()
  const _camera = THREE.OrthographicCamera.new(0, 1, 0, 1, 0, 1)
  var _clearVertices List<double> = []
  var _textureA dynamic
  var _textureB dynamic
  var _count = 0
  var _first = 0

  def new(width int, height int) {
    self.width = width
    self.height = height

    _textureA = THREE.WebGLRenderTarget.new(width * CELL_SIZE, height * CELL_SIZE, {
      "minFilter": THREE.LinearFilter,
      "magFilter": THREE.LinearFilter,
      "format": THREE.RGBFormat,
    })
    _textureA.texture.generateMipmaps = false

    _textureB = THREE.WebGLRenderTarget.new(width * CELL_SIZE, height * CELL_SIZE, {
      "minFilter": THREE.LinearFilter,
      "magFilter": THREE.LinearFilter,
      "format": THREE.RGBFormat,
    })
    _textureB.texture.generateMipmaps = false

    _depthTexture = THREE.WebGLRenderTarget.new(1024, 1024, {
      "minFilter": THREE.NearestFilter,
      "magFilter": THREE.NearestFilter,
      "format": THREE.RGBFormat,
    })
    _depthTexture.texture.generateMipmaps = false

    var uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
    ])

    depthMaterial = THREE.ShaderMaterial.new({
      "uniforms": uniforms,
      "vertexShader": "
        varying vec4 position_;

        void main() {
          position_ = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          gl_Position = position_;
        }
      ",
      "fragmentShader": "
        varying vec4 position_;

        void main() {
          float depth = position_.z / position_.w * 0.5 + 0.5;
          vec3 v = fract(depth * vec3(1.0, 256.0, 65536.0));
          v = floor(v * 256.0) / 256.0;
          gl_FragColor = vec4(v, 1.0);
        }
      ",
    })

    uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      {"map": {"type": "t", "value": null}},
      {"previous": {"type": "t", "value": null}},
      {"rayLight": {"type": "v3", "value": THREE.Vector3.new()}},
      {"accumulationFactor": {"type": "f", "value": 1.0 / 64}},
    ])
    uniforms.map.value = _depthTexture

    updateMaterial = THREE.ShaderMaterial.new({
      "uniforms": uniforms,
      "vertexShader": "
        attribute vec2 updateUV;
        attribute vec3 updatePosition;
        varying vec3 worldPosition;
        varying vec4 clipPosition;
        varying vec2 updateUV_;

        void main() {
          updateUV_ = updateUV;
          worldPosition = updatePosition;
          clipPosition = projectionMatrix * modelViewMatrix * vec4(updatePosition, 1.0);
          gl_Position = vec4(updateUV * 2.0 - 1.0, 0.0, 1.0);
        }
      ",
      "fragmentShader": "
        uniform sampler2D map;
        uniform sampler2D previous;
        uniform float accumulationFactor;
        uniform vec3 rayLight;
        varying vec3 worldPosition;
        varying vec4 clipPosition;
        varying vec2 updateUV_;

        void main() {
          vec3 position = clipPosition.xyz / clipPosition.w * 0.5 + 0.5;
          vec3 encoded = texture2D(map, position.xy).rgb;
          float depth = dot(encoded, vec3(1.0, 1.0 / 256.0, 1.0 / 65536.0));
          vec3 normal = cross(dFdx(worldPosition), dFdy(worldPosition));
          float occlusion = float(depth + 1.0 / 256.0 < position.z || dot(rayLight, normal) < 0.0);

          vec4 previous8 = texture2D(previous, updateUV_);
          vec2 previous16 = vec2(
            dot(previous8.rg, vec2(1.0, 1.0 / 256.0)),
            dot(previous8.ba, vec2(1.0, 1.0 / 256.0)));
          vec2 next16 = mix(previous16, vec2(occlusion, 1.0), accumulationFactor);
          vec4 next8 = fract(vec4(next16.x * vec2(1.0, 256.0), next16.y * vec2(1.0, 256.0)));
          next8 = floor(next8 * 256.0) / 256.0;
          gl_FragColor = next8;
        }
      ",
      "derivatives": true,
    })

    uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
    ])

    _clearMaterial = THREE.ShaderMaterial.new({
      "uniforms": uniforms,
      "vertexShader": "
        void main() {
          gl_Position = vec4(position, 1.0);
        }
      ",
      "fragmentShader": "
        void main() {
          gl_FragColor = vec4(0.0);
        }
      ",
    })

    # Create a large linked list
    var count = width * height
    _links = Int32Array.new(count)
    for i in 0..count {
      _links[i] = i + 1 == count ? INDEX_NULL : i + 1
    }
  }

  def texture dynamic {
    return _textureA
  }

  def allocate int {
    if _first == INDEX_NULL {
      return INDEX_NULL
    }

    var index = _first
    _first = _links[index]
    assert(_first != INDEX_USED)

    # Debugging to catch double-allocates and double-frees
    if !RELEASE {
      _links[index] = INDEX_USED
    }

    # Clear this quad next time we render
    outerQuadForIndex(index, _box2)
    _appendClearTriangle(_box2.min.x, _box2.min.y, _box2.max.x, _box2.min.y, _box2.max.x, _box2.max.y)
    _appendClearTriangle(_box2.min.x, _box2.min.y, _box2.max.x, _box2.max.y, _box2.min.x, _box2.max.y)

    return index
  }

  def _appendClearTriangle(ax double, ay double, bx double, by double, cx double, cy double) {
    _clearVertices.append(ax * 2 - 1)
    _clearVertices.append(ay * 2 - 1)
    _clearVertices.append(0)

    _clearVertices.append(bx * 2 - 1)
    _clearVertices.append(by * 2 - 1)
    _clearVertices.append(0)

    _clearVertices.append(cx * 2 - 1)
    _clearVertices.append(cy * 2 - 1)
    _clearVertices.append(0)
  }

  def free(index int) {
    if index != INDEX_NULL {
      assert(index >= 0 && index < width * height)
      assert(_links[index] == INDEX_USED)
      _links[index] = _first
      _first = index
    }
  }

  def outerQuadForIndex(index int, box dynamic) {
    var s double = index % width
    var t double = index / width
    box.min.x = s / width
    box.min.y = t / height
    box.max.x = (s + 1) / width
    box.max.y = (t + 1) / height
  }

  def innerQuadForIndex(index int, box dynamic) {
    var s double = (index % width) * CELL_SIZE
    var t double = (index / width) * CELL_SIZE
    box.min.x = (s + 0.5) / (width * CELL_SIZE)
    box.min.y = (t + 0.5) / (height * CELL_SIZE)
    box.max.x = (s + (CELL_SIZE - 0.5)) / (width * CELL_SIZE)
    box.max.y = (t + (CELL_SIZE - 0.5)) / (height * CELL_SIZE)
  }

  def render(renderer dynamic, terrain Terrain, light dynamic) {
    if _count % 2 == 0 {
      var theta = Math.random * (2 * Math.PI)
      var phi = Math.asin(2 * Math.random - 1)
      _axisZ.set(
        Math.cos(theta) * Math.cos(phi),
        Math.sin(phi),
        Math.sin(theta) * Math.cos(phi))
      _axisZ.y = Math.abs(_axisZ.y as double)
      if _count % 6 == 0 {
        _axisZ.y += 1
        _axisZ.normalize()
      } else {
        _axisZ.multiplyScalar(0.1).add(light.position).normalize()
      }
      _axisY.set(_axisZ.y, _axisZ.z, _axisZ.x).cross(_axisZ).normalize()
      _axisX.copy(_axisY).cross(_axisZ).normalize()

      _box3.min.set(Math.INFINITY, Math.INFINITY, Math.INFINITY)
      _box3.max.set(-Math.INFINITY, -Math.INFINITY, -Math.INFINITY)

      # Fit a bounding box around the terrain
      for chunk in terrain.chunks {
        for i in 0..8 {
          var x = chunk.startX + ((i & 1) != 0 ? Chunk.SIZE_X : 0)
          var y = chunk.startY + ((i & 2) != 0 ? Chunk.SIZE_Y : 0)
          var z = chunk.startZ + ((i & 4) != 0 ? Chunk.SIZE_Z : 0)
          _vector3.set(x, y, z)
          _vector3.set(_vector3.dot(_axisX), _vector3.dot(_axisY), _vector3.dot(_axisZ))
          _box3.expandByPoint(_vector3)
        }
      }

      # Guard against small rounding errors
      _box3.expandByScalar(1)

      # Create the orthographic projection
      _camera.left   = _box3.min.x
      _camera.right  = _box3.max.x
      _camera.bottom = _box3.min.y
      _camera.top    = _box3.max.y
      _camera.near   = -_box3.max.z
      _camera.far    = -_box3.min.z
      _camera.matrix.makeBasis(_axisX, _axisY, _axisZ)
      _camera.matrix.decompose(_camera.position, _camera.quaternion, _camera.scale)
      _camera.updateProjectionMatrix()

      # Render a depth map of the scene
      renderer.setViewport(0, 0, _depthTexture.width, _depthTexture.height)
      renderer.render(depthScene, _camera, _depthTexture)
    }

    # Accumulate the depth map onto the light map texture
    else {
      renderer.autoClear = false
      renderer.setViewport(0, 0, _textureA.width, _textureA.height)

      if !_clearVertices.isEmpty {
        var geometry = THREE.BufferGeometry.new()
        geometry.addAttribute("position", THREE.BufferAttribute.new(Float32Array.new(_clearVertices), 3))
        var clearMesh = THREE.Mesh.new(geometry, _clearMaterial)
        clearMesh.frustumCulled = false
        _clearScene.add(clearMesh)
        renderer.render(_clearScene, _camera, _textureA)
        _clearScene.remove(clearMesh)
        _clearVertices = []
      }

      updateMaterial.uniforms.rayLight.value.copy(_axisZ)
      updateMaterial.uniforms.previous.value = _textureA

      renderer.render(updateScene, _camera, _textureB)
      renderer.autoClear = true

      var swap = _textureA
      _textureA = _textureB
      _textureB = swap
    }

    _count++
  }
}

namespace Lightmap {
  const INDEX_NULL = -1
  const INDEX_USED = -2
  const CELL_SIZE = 2
}
