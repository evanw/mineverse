class Terrain {
  const _world World
  const _texture dynamic
  const _material dynamic
  const _chunkList List<Chunk> = []
  const _chunkMap IntMap<Chunk> = {}
  const _group = THREE.Group.new()
  const _frustum = THREE.Frustum.new()
  const _box = THREE.Box3.new()
  const _matrix = THREE.Matrix4.new()
  const _drawDistance = 128

  def new(world World) {
    _world = world
    _texture = THREE.TextureLoader.new().load("terrain.png")
    _texture.minFilter = _texture.magFilter = THREE.NearestFilter

    var uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.lights,
      {"clearColor": {"type": "c", "value": world.clearColor}},
      {"drawDistance": {"type": "f", "value": 0}},
    ])
    uniforms.map.value = _texture

    _material = THREE.ShaderMaterial.new({
      "uniforms": uniforms,
      "vertexShader": "
        attribute vec3 metadata;
        varying vec3 position_;
        varying vec3 metadata_;

        void main() {
          vec4 cameraSpacePosition = modelViewMatrix * vec4(position, 1.0);
          position_ = cameraSpacePosition.xyz;
          metadata_ = metadata;
          gl_Position = projectionMatrix * cameraSpacePosition;
        }
      ",
      "fragmentShader": "\n".join([
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.map_pars_fragment,
        THREE.ShaderChunk.lights_lambert_pars_vertex,
        "
        uniform vec3 clearColor;
        uniform float drawDistance;
        varying vec3 position_;
        varying vec3 metadata_;

        void main() {
          vec2 coord = metadata_.xy;
          float occlusion = metadata_.z;
          vec3 color = inputToLinear(texture2D(map, coord).rgb);
          vec3 normal = normalize(cross(dFdx(position_), dFdy(position_)));
          float fade = max(0.0, 1.0 - length(position_) / drawDistance);

          vec3 diffuse = vec3(0.0);
          for (int i = 0; i < MAX_DIR_LIGHTS; i++) {
            diffuse += directionalLightColor[i] * max(0.0, dot(normal, directionalLightDirection[i]));
          }

          color *= 0.1 * occlusion + 0.9 * diffuse;
          color = mix(inputToLinear(clearColor), color, fade * fade);
          color = linearToOutput(color);
          gl_FragColor = vec4(color, 1.0);
        }
        ",
      ]),
      "derivatives": true,
      "lights": true,
      "map": true,
    })

    world.scene.add(_group)
  }

  def _update(camera dynamic) {
    _frustum.setFromMatrix(_matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse))

    var maxCenterDistance = _drawDistance + Math.sqrt(Chunk.SIZE_X * Chunk.SIZE_X + Chunk.SIZE_Y * Chunk.SIZE_Y + Chunk.SIZE_Z * Chunk.SIZE_Z) / 2
    var eye = camera.position

    var xmin = Math.floor((eye.x - maxCenterDistance) / Chunk.SIZE_X) as int
    var xmax = Math.ceil((eye.x + maxCenterDistance) / Chunk.SIZE_X) as int

    var ymin = Math.max(0, Math.floor((eye.y - maxCenterDistance) / Chunk.SIZE_Y) as int)
    var ymax = Math.min(2, Math.ceil((eye.y + maxCenterDistance) / Chunk.SIZE_Y) as int)

    var zmin = Math.floor((eye.z - maxCenterDistance) / Chunk.SIZE_Z) as int
    var zmax = Math.ceil((eye.z + maxCenterDistance) / Chunk.SIZE_Z) as int

    # Remove old chunks
    var i = 0
    while i < _chunkList.count {
      var chunk = _chunkList[i]
      if distance(eye.x, eye.y, eye.z, chunk.startX + Chunk.SIZE_X * 0.5, chunk.startY + Chunk.SIZE_Y * 0.5, chunk.startZ + Chunk.SIZE_Z * 0.5) > maxCenterDistance {
        _chunkMap.remove(chunk.key)
        _chunkList.removeAt(i)
        chunk.destroy
      } else {
        i++
      }
    }

    var bestStartX = 0
    var bestStartY = 0
    var bestStartZ = 0
    var bestScore = -Math.INFINITY

    # Add one new chunk
    for x in xmin..xmax {
      var startX = x * Chunk.SIZE_X

      for y in ymin..ymax {
        var startY = y * Chunk.SIZE_Y

        for z in zmin..zmax {
          var startZ = z * Chunk.SIZE_Z
          var centerDistance = distance(eye.x, eye.y, eye.z, startX + Chunk.SIZE_X * 0.5, startY + Chunk.SIZE_Y * 0.5, startZ + Chunk.SIZE_Z * 0.5)

          if centerDistance > maxCenterDistance {
            continue
          }

          var key = createKey(startX, startY, startZ)
          var chunk = _chunkMap.get(key, null)

          if chunk == null {
            _box.min.set(startX, startY, startZ)
            _box.max.set(startX + Chunk.SIZE_X, startY + Chunk.SIZE_Y, startZ + Chunk.SIZE_Z)

            var isInView = _frustum.intersectsBox(_box)
            var score = isInView ? _drawDistance - centerDistance : -centerDistance

            if score > bestScore {
              bestStartX = startX
              bestStartY = startY
              bestStartZ = startZ
              bestScore = score
            }
          }
        }
      }
    }

    if bestScore > -Math.INFINITY {
      var chunk = Chunk.new(_group, _material, bestStartX, bestStartY, bestStartZ)
      chunk.generate
      _chunkMap[createKey(bestStartX, bestStartY, bestStartZ)] = chunk
      _chunkList.append(chunk)

      for j in 0..6 {
        var direction = j as Direction
        var otherX = bestStartX + direction.deltaX * Chunk.SIZE_X
        var otherY = bestStartY + direction.deltaY * Chunk.SIZE_Y
        var otherZ = bestStartZ + direction.deltaZ * Chunk.SIZE_Z
        var other = _chunkMap.get(createKey(otherX, otherY, otherZ), null)

        if other != null {
          chunk.linkTo(other, direction)
        }
      }
    }
  }

  def tick(camera dynamic) {
    _update(camera)
    for chunk in _chunkList {
      chunk.update
    }
    _material.uniforms.drawDistance.value = _drawDistance
  }

  def get(x int, y int, z int) Cell {
    var key = createKey(
      x & ~(Chunk.SIZE_X - 1),
      y & ~(Chunk.SIZE_Y - 1),
      z & ~(Chunk.SIZE_Z - 1))
    var chunk = _chunkMap.get(key, null)
    if chunk != null {
      return chunk.get(x, y, z)
    }
    return .EMPTY
  }

  def _isEmpty(xmin int, xmax int, ymin int, ymax int, zmin int, zmax int) bool {
    for x in xmin..xmax + 1 {
      for y in ymin..ymax + 1 {
        for z in zmin..zmax + 1 {
          if get(x, y, z) != .EMPTY {
            return false
          }
        }
      }
    }
    return true
  }

  def moveAABB(aabb AABB, delta dynamic) {
    _moveAlongAxis(aabb, 0, delta.x)
    _moveAlongAxis(aabb, 1, delta.y)
    _moveAlongAxis(aabb, 2, delta.z)
  }

  const _min = THREE.Vector3.new()
  const _max = THREE.Vector3.new()

  def _moveAlongAxis(aabb AABB, axis int, delta double) {
    const EPSILON = 0.0001

    var min = _min.copy(aabb.center).sub(aabb.radius).floor()
    var max = _max.copy(aabb.center).add(aabb.radius).ceil()
    var center = aabb.center.getComponent(axis)
    var radius = aabb.radius.getComponent(axis)

    if delta < 0 {
      var minDelta = Math.floor(center - radius + delta) as int
      for i = Math.floor(center - radius - 1) as int; i >= minDelta; i-- {
        if !_isEmpty(
            axis == 0 ? i : min.x, axis == 0 ? i : max.x - 1,
            axis == 1 ? i : min.y, axis == 1 ? i : max.y - 1,
            axis == 2 ? i : min.z, axis == 2 ? i : max.z - 1) {
          aabb.center.setComponent(axis, i + 1 + radius + EPSILON)
          return
        }
      }
    }

    else if delta > 0 {
      var maxDelta = Math.ceil(center + radius + delta - 1) as int
      for i = Math.ceil(center + radius) as int; i <= maxDelta; i++ {
        if !_isEmpty(
            axis == 0 ? i : min.x, axis == 0 ? i : max.x - 1,
            axis == 1 ? i : min.y, axis == 1 ? i : max.y - 1,
            axis == 2 ? i : min.z, axis == 2 ? i : max.z - 1) {
          aabb.center.setComponent(axis, i - radius - EPSILON)
          return
        }
      }
    }

    aabb.center.setComponent(axis, center + delta)
  }
}

namespace Terrain {
  def distance(x1 double, y1 double, z1 double, x2 double, y2 double, z2 double) double {
    x1 -= x2
    y1 -= y2
    z1 -= z2
    return Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1)
  }

  def createKey(x int, y int, z int) int {
    assert(x % Chunk.SIZE_X == 0)
    assert(y % Chunk.SIZE_Y == 0)
    assert(z % Chunk.SIZE_Z == 0)
    const SHIFT = 32 / 3
    const MASK = (1 << SHIFT) - 1
    return
      ((x >> Chunk.SHIFT_X) & MASK) |
      (((y >> Chunk.SHIFT_Y) & MASK) << SHIFT) |
      (((z >> Chunk.SHIFT_Z) & MASK) << (2 * SHIFT))
  }

  def _noise(x int, y int) double {
    var n = x + y * 57
    n = (n << 13) ^ n
    return 1 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7FFFFFFF) * 0.000000000931322574615478515625
  }

  def _smooth(f double) double {
    return f * f * (3 - 2 * f)
  }

  def _smoothNoise(x double, y double) double {
    var ix = Math.floor(x) as int
    var iy = Math.floor(y) as int
    var dx = _smooth(x - ix)
    var dy = _smooth(y - iy)
    var total = 0.0
    for i in 0..4 {
        var bx = i & 1
        var by = (i >> 1) & 1
        total += _noise(ix + bx, iy + by) *
          (bx != 0 ? dx : 1 - dx) *
          (by != 0 ? dy : 1 - dy)
    }
    return total
  }

  def height(x double, y double) double {
    var a = 0.0
    var b = 1.0

    for i in 0..3 {
      a += _smoothNoise(x, y) * b
      b *= 0.5
      x *= 2
      y *= 2
    }

    return a
  }
}
